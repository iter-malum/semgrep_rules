rules:
  - id: Possible-Race-Condition
    metadata:
      author: Victor 4ernyak <https://t.me/iter_malum>
      confidence: MEDIUM
      category: security
      cwe:
        - "CWE-366: Race Condition within a Thread"
        - "CWE-367: Time-of-check Time-of-use (TOCTOU)"
        - "CWE-362: Concurrent Execution using Shared Resource"
      vulnerability_class:
        - Concurrency
      owasp:
        - A05:2021 - Security Misconfiguration
      references:
        - https://cwe.mitre.org/data/definitions/366.html
        - https://cwe.mitre.org/data/definitions/367.html
        - https://cwe.mitre.org/data/definitions/362.html
        - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
      technology:
        - c
        - cpp
    languages:
      - c
      - c++
    severity: WARNING
    message: >
      Potential race condition detected. Multiple threads may access shared 
      resources without proper synchronization, leading to undefined behavior, 
      data corruption, or security vulnerabilities. Use mutexes, atomic 
      operations, or other synchronization primitives to protect shared state.
    pattern-either:
    # TOCTOU patterns - Block 1
    - patterns:
      - pattern-either:
        - pattern: access($PATH, $MODE)
        - pattern: stat($PATH, $BUF)
        - pattern: lstat($PATH, $BUF)
      - pattern-inside: |
          if ($FUNC($PATH, ...) == 0) {
            ...
          }
      - pattern-either:
        - pattern: fopen($PATH, $MODE)
        - pattern: open($PATH, $FLAGS)
        - pattern: unlink($PATH)
        - pattern: mkdir($PATH, $MODE)
        - pattern: rename($PATH, $NEW_PATH)
      - pattern-inside: |
          if ($FUNC($PATH, ...) == 0) {
            ...
            $OPERATION($PATH, ...);
            ...
          }
      - pattern-not-inside: |
          if ($FUNC($PATH, ...) == 0) {
            ...
            pthread_mutex_lock(...);
            ...
            $OPERATION($PATH, ...);
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          if ($FUNC($PATH, ...) == 0) {
            ...
            std::lock_guard<...> ...;
            ...
            $OPERATION($PATH, ...);
            ...
          }
    
    # Non-atomic operations on shared variables - Blocks 2, 9, 10
    - patterns:
      - pattern-either:
        - pattern: $VAR++
        - pattern: $VAR--
        - pattern: ++$VAR
        - pattern: --$VAR
        - pattern: $VAR += $EXPR
        - pattern: $VAR -= $EXPR
        - pattern: $VAR = $VALUE
        - pattern: $VAR == $VALUE
        - pattern: $VAR != $VALUE
        - pattern: $VAR < $VALUE
        - pattern: $VAR > $VALUE
      - metavariable-regex:
          metavariable: $VAR
          regex: '^(global|shared|g_|connection|cpp_shared|logger|pool|cache|obj|singleton_instance|signal_flag).*'
      - pattern-not-inside: |
          pthread_mutex_lock(...);
          ...
          $VAR++;
          ...
          pthread_mutex_unlock(...);
      - pattern-not-inside: |
          std::lock_guard<...> ...;
          ...
          $VAR++;
          ...
      - pattern-not-inside: |
          std::atomic<...> ...;
          ...
          $VAR++;
          ...
    
    # Thread creation without synchronization - Block 4
    - patterns:
      - pattern-either:
        - pattern: pthread_create($THREAD, $ATTR, $FUNC, $ARG)
        - pattern: _beginthread($FUNC, ...)
        - pattern: _beginthreadex($FUNC, ...)
        - pattern: CreateThread($ATTR, $SIZE, $FUNC, $ARG, ...)
      - pattern-not-inside: |
          pthread_mutex_init(...);
          ...
          pthread_create($THREAD, $ATTR, $FUNC, $ARG);
          ...
      - pattern-not-inside: |
          std::mutex $MUTEX;
          ...
          pthread_create($THREAD, $ATTR, $FUNC, $ARG);
          ...
    - patterns:
      - pattern-either:
        - pattern: $THREAD.join()
        - pattern: $THREAD.detach()
        - pattern: $THREAD.get_id()
      - pattern-not-inside: |
          std::mutex $MUTEX;
          ...
          $THREAD.join();
          ...
    
    # Check-then-act patterns - Block 5
    - patterns:
      - pattern: if ($PTR != NULL) { ... }
      - pattern-inside: |
          if ($PTR != NULL) {
            ...
            free($PTR);
            ...
          }
          ...
          if ($PTR != NULL) {
            ...
            $USE = $PTR;
            ...
          }
      - pattern-not-inside: |
          if ($PTR != NULL) {
            ...
            pthread_mutex_lock(...);
            ...
            free($PTR);
            ...
            pthread_mutex_unlock(...);
            ...
          }
          ...
          if ($PTR != NULL) {
            ...
            $USE = $PTR;
            ...
          }
      - pattern-inside: |
          if ($PTR) {
            ...
            free($PTR);
            ...
          }
          ...
          if ($PTR) {
            ...
            $USE = $PTR;
            ...
          }
      - pattern-inside: |
          if ($PTR != NULL) {
            if ($COND) {
              ...
              free($PTR);
              ...
            }
          }
          ...
          if ($PTR != NULL) {
            ...
            $USE = $PTR;
            ...
          }
    
    # Double free patterns - Block 6
    - patterns:
      - pattern: free($PTR)
      - pattern-inside: |
          if ($COND) {
            ...
            free($PTR);
            ...
          }
          ...
          free($PTR);
          ...
      - pattern-inside: |
          if ($COND) {
            ...
            free($PTR);
            ...
          }
          ...
          if ($PTR != NULL) {
            ...
            free($PTR);
            ...
          }
      - pattern-not-inside: |
          if ($COND) {
            ...
            pthread_mutex_lock(...);
            ...
            free($PTR);
            ...
            pthread_mutex_unlock(...);
            ...
          }
          ...
          free($PTR);
          ...
    
    # Double close patterns - Block 6
    - patterns:
      - pattern-either:
        - pattern: close($FD)
        - pattern: fclose($FP)
      - pattern-inside: |
          if ($COND) {
            ...
            $CLOSE($FD);
            ...
          }
          ...
          $CLOSE($FD);
          ...
      - pattern-not-inside: |
          if ($COND) {
            ...
            pthread_mutex_lock(...);
            ...
            $CLOSE($FD);
            ...
            pthread_mutex_unlock(...);
            ...
          }
          ...
          $CLOSE($FD);
          ...
    
    # Environment variable race - Block 8
    - patterns:
      - pattern-either:
        - pattern: setenv($NAME, $VALUE, $OVR)
        - pattern: putenv($STRING)
        - pattern: unsetenv($NAME)
      - pattern-not-inside: |
          pthread_mutex_lock(...);
          ...
          setenv($NAME, $VALUE, $OVR);
          ...
          pthread_mutex_unlock(...);
    
    # Signal handler race - Block 7
    - patterns:
      - pattern-either:
        - pattern: signal($SIG, $HANDLER)
        - pattern: sigaction($SIG, $ACT, $OACT)
      - pattern-not-inside: |
          pthread_mutex_lock(...);
          ...
          signal($SIG, $HANDLER);
          ...
          pthread_mutex_unlock(...);
    
    # Singleton lazy initialization - Block 3
    - patterns:
      - pattern: if (!$INSTANCE) { ... }
      - pattern-inside: |
          if (!$INSTANCE) {
            ...
            $INSTANCE = $ALLOC(...);
            ...
          }
      - pattern-not-inside: |
          if (!$INSTANCE) {
            ...
            pthread_mutex_lock(...);
            ...
            $INSTANCE = $ALLOC(...);
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          if (!$INSTANCE) {
            ...
            std::lock_guard<...> ...;
            ...
            $INSTANCE = $ALLOC(...);
            ...
          }
    
    # C++ class member access without synchronization - Block 11
    - patterns:
      - pattern-either:
        - pattern: $OBJ.$METHOD(...)
        - pattern: $OBJ->$METHOD(...)
        - pattern: $OBJ.$MEMBER
        - pattern: $OBJ->$MEMBER
      - pattern-inside: |
          void $FUNC(...) {
            ...
            $OBJ.$MEMBER;
            ...
          }
      - pattern-not-inside: |
          void $FUNC(...) {
            ...
            pthread_mutex_lock(...);
            ...
            $OBJ.$MEMBER;
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          void $FUNC(...) {
            ...
            std::lock_guard<...> ...;
            ...
            $OBJ.$MEMBER;
            ...
          }
    
    # Connection pool access without synchronization - Block 12
    - patterns:
      - pattern: $OBJ.$MEMBER
      - pattern-inside: |
          $RET_TYPE get_connection_vulnerable($OBJ_TYPE $OBJ) {
            ...
            if ($OBJ.$MEMBER < $OBJ.$OTHER_MEMBER) {
              ...
              $OBJ.$MEMBER++;
              ...
            }
            ...
          }
      - pattern-inside: |
          void release_connection_vulnerable($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            $OBJ.$MEMBER--;
            ...
          }
      - pattern-not-inside: |
          $RET_TYPE get_connection_safe($OBJ_TYPE $OBJ) {
            ...
            pthread_mutex_lock(...);
            ...
            if ($OBJ.$MEMBER < $OBJ.$OTHER_MEMBER) {
              ...
              $OBJ.$MEMBER++;
              ...
            }
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          void release_connection_safe($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            pthread_mutex_lock(...);
            ...
            $OBJ.$MEMBER--;
            ...
            pthread_mutex_unlock(...);
            ...
          }
    
    # Logger access without synchronization - Block 13
    - patterns:
      - pattern: $OBJ.$MEMBER
      - pattern-inside: |
          void log_message_vulnerable($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            if ($OBJ.$MEMBER) {
              ...
              $WRITE($OBJ.$MEMBER, ...);
              ...
              $OBJ.$OTHER_MEMBER++;
              ...
            }
            ...
          }
      - pattern-inside: |
          void close_logger_vulnerable($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            if ($COND) {
              ...
              $CLOSE($OBJ.$MEMBER);
              ...
            }
            ...
            $CLOSE($OBJ.$MEMBER);
            ...
          }
      - pattern-not-inside: |
          void log_message_safe($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            pthread_mutex_lock(...);
            ...
            if ($OBJ.$MEMBER) {
              ...
              $WRITE($OBJ.$MEMBER, ...);
              ...
              $OBJ.$OTHER_MEMBER++;
              ...
            }
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          void close_logger_safe($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            pthread_mutex_lock(...);
            ...
            if ($COND) {
              ...
              $CLOSE($OBJ.$MEMBER);
              ...
            }
            ...
            pthread_mutex_unlock(...);
            ...
          }
    
    # Cache access without synchronization - Block 14
    - patterns:
      - pattern: $OBJ.$MEMBER
      - pattern-inside: |
          char *cache_get_vulnerable($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            for ($INIT; $COND; $INC) {
              ...
              if ($COMPARE($OBJ.$MEMBER[$INDEX], $ARG) == 0) {
                ...
                return $OBJ.$OTHER_MEMBER[$INDEX];
                ...
              }
              ...
            }
            ...
          }
      - pattern-inside: |
          void cache_set_vulnerable($OBJ_TYPE $OBJ, $ARG_TYPE $ARG1, $ARG_TYPE $ARG2) {
            ...
            if ($OBJ.$MEMBER < $OBJ.$OTHER_MEMBER) {
              ...
              $OBJ.$MEMBER1[$OBJ.$MEMBER] = $ALLOC($ARG1);
              ...
              $OBJ.$MEMBER2[$OBJ.$MEMBER] = $ALLOC($ARG2);
              ...
              $OBJ.$MEMBER++;
              ...
            }
            ...
          }
      - pattern-not-inside: |
          char *cache_get_safe($OBJ_TYPE $OBJ, $ARG_TYPE $ARG) {
            ...
            pthread_mutex_lock(...);
            ...
            for ($INIT; $COND; $INC) {
              ...
              if ($COMPARE($OBJ.$MEMBER[$INDEX], $ARG) == 0) {
                ...
                return $OBJ.$OTHER_MEMBER[$INDEX];
                ...
              }
              ...
            }
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          void cache_set_safe($OBJ_TYPE $OBJ, $ARG_TYPE $ARG1, $ARG_TYPE $ARG2) {
            ...
            pthread_mutex_lock(...);
            ...
            if ($OBJ.$MEMBER < $OBJ.$OTHER_MEMBER) {
              ...
              $OBJ.$MEMBER1[$OBJ.$MEMBER] = $ALLOC($ARG1);
              ...
              $OBJ.$MEMBER2[$OBJ.$MEMBER] = $ALLOC($ARG2);
              ...
              $OBJ.$MEMBER++;
              ...
            }
            ...
            pthread_mutex_unlock(...);
            ...
          }
    
    # Reference counting without synchronization - Block 18
    - patterns:
      - pattern: $OBJ.$MEMBER
      - pattern-inside: |
          void ref_acquire_vulnerable($OBJ_TYPE $OBJ) {
            ...
            $OBJ.$MEMBER++;
            ...
          }
      - pattern-inside: |
          void ref_release_vulnerable($OBJ_TYPE $OBJ) {
            ...
            $OBJ.$MEMBER--;
            ...
            if ($OBJ.$MEMBER == 0) {
              ...
              free($OBJ.$OTHER_MEMBER);
              ...
              free($OBJ);
              ...
            }
            ...
          }
      - pattern-not-inside: |
          void ref_acquire_safe($OBJ_TYPE $OBJ) {
            ...
            pthread_mutex_lock(...);
            ...
            $OBJ.$MEMBER++;
            ...
            pthread_mutex_unlock(...);
            ...
          }
      - pattern-not-inside: |
          void ref_release_safe($OBJ_TYPE $OBJ) {
            ...
            pthread_mutex_lock(...);
            ...
            $OBJ.$MEMBER--;
            ...
            if ($OBJ.$MEMBER == 0) {
              ...
              free($OBJ.$OTHER_MEMBER);
              ...
              free($OBJ);
              ...
            }
            ...
            pthread_mutex_unlock(...);
            ...
          }